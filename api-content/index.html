{"posts":[{"title":"算法图解 7.3 换钢琴 代码实现","content":"#!/usr/bin/env python coding=utf-8 ''' @version: @Author: steven @Date: 2020-04-17 21:30:12 @LastEditors: steven @LastEditTime: 2020-04-17 23:38:12 @Description: 算法图解 7.3 换钢琴 代码实现 ''' 添加节点和邻居 graph = {} graph[&quot;muscbk&quot;] = {} # 起点为musicbook,简称muscbk graph[&quot;muscbk&quot;][&quot;record&quot;] = 5 graph[&quot;muscbk&quot;][&quot;poster&quot;] = 0 graph[&quot;record&quot;] = {} graph[&quot;record&quot;][&quot;guitar&quot;] = 15 graph[&quot;record&quot;][&quot;grum&quot;] = 20 graph[&quot;poster&quot;] = {} graph[&quot;poster&quot;][&quot;guitar&quot;] = 30 graph[&quot;poster&quot;][&quot;grum&quot;] = 35 graph[&quot;guitar&quot;] = {} graph[&quot;guitar&quot;][&quot;piano&quot;] = 20 graph[&quot;grum&quot;] = {} graph[&quot;grum&quot;][&quot;piano&quot;] = 10 graph[&quot;piano&quot;] = {} # 终点piano没有邻居 存储每个节点开销的散列表 infinity = float(&quot;inf&quot;) costs = {} costs[&quot;record&quot;] = 5 costs[&quot;poster&quot;] = 0 costs[&quot;guitar&quot;] = infinity costs[&quot;grum&quot;] = infinity costs[&quot;piano&quot;] = infinity 存储父节点的散列表 parents = {} parents[&quot;record&quot;] = &quot;muscbk&quot; parents[&quot;poster&quot;] = &quot;muscbk&quot; parents[&quot;guitar&quot;] = None parents[&quot;drum&quot;] = None parents[&quot;piano&quot;] = None processed = [] # 一个数组，用于记录处理过的节点。因为对于同一个节点，不用处理多次。 def find_lowest_cost_node(costs): # (2).to initial lowest_cost,removes other guessworks. lowest_cost = float(&quot;inf&quot;) # to initial cost node. lowest_cost_node = None # 遍历所有的节点 for node in costs: cost = costs[node] # 如果当前节点的开销更低且未处理过 if cost &lt; lowest_cost and node not in processed: # 就将其视为开销最低的节点 lowest_cost = cost lowest_cost_node = node return lowest_cost_node 在未处理的节点中找出开销最小的节点 node = find_lowest_cost_node(costs) 这个while循环在所有节点都被处理过后结束 while node is not None: cost = costs[node] # 遍历当前节点的所有邻居 neighbors = graph[node] for n in neighbors.keys(): new_cost = cost + neighbors[n] # 如果经当前节点前往该邻居更近 if costs[n] &gt; new_cost: # 就更新该邻居的开销 costs[n] = new_cost # 同时将该邻居的父节点设置为当前节点 parents[n] = node # 将当前节点标记为处理过 processed.append(node) # 找出接下来要处理的节点，并做循环 node = find_lowest_cost_node(costs) if name == 'main': print(&quot;Cost from the start to each node:&quot;) print(costs) ","link":"https://StevenJokes.github.io/post/suan-fa-tu-jie-73-huan-gang-qin-dai-ma-shi-xian/"},{"title":"我的穷逼配置","content":"ha, ","link":"https://StevenJokes.github.io/post/wo-de-qiong-bi-pei-zhi/"},{"title":"Hello，everybody！","content":"欢迎来的我的 Gridea 的博客🙊！ gridea-start 基本配置就跟上面一样。 只是后来为了同步方便，我又把我的文档放在OneDrive里，那这个时候就需要注意了，在换我这个主题Chic（感谢大佬ITJoker233，祝早日拿高薪Offer！) 那就需要再这么操作一下：设置- 哈哈，希望别的Win10小伙伴，不要和我一样犯傻哦！ ","link":"https://StevenJokes.github.io/post/helloeverybody/"}]}